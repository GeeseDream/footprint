Java 线程
=================

什么是线程
-------------------

线程是操作系统能够进行运算调度的最小单位，有时被称为轻量级进程。一个进程中可以并发多个线程，每条线程并行执行不同的任务。

同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。

一个进程可以有很多线程来处理，每条线程并行执行不同的任务。如果进程要完成的任务很多，这样需很多线程，也要调用很多核心，在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见的，提高了程序的执行吞吐率。

在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，虽然多任务比不上多核，但因为具备多线程的能力，从而提高了程序的执行效率。

线程优先级
------------

操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。
线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

.. note::

    Java线程中优先级的范围为从1~10，可以通过setPriority(int)方法来修改线程优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。



线程状态
----------------

在给定的一个时刻，线程只能处于其中的一个状态。使用jstack工具可以查看运行时线程信息。

=============   ===================================================================================================
状态名称         说 明
=============   ===================================================================================================
NEW             初始状态,线被构建,但是还没有调用I start0方法
RUNNABLE        运行状态, Java 线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”
BLOCKED         阻寒状态,表示线程阻塞十锁
WAITING         等待状态,表示线程进人等待状态,进人该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)
TIME WAITING    超时等待状态,该状态不同丁 WAITING,它是可以在指定的时间自行返回的
TERMINATED      终止状态,表示当前线程已经执行完毕
=============   ===================================================================================================

Java 线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如

.. image:: threadstateflow.png
    :alt: 线程流程图
    
Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态。

Daemon线程
-----------

Daemon线程是一种支持型线程，它主要被用作程序中后台调度以及支持性工作。这意味着，Java虚拟机中必须存在一个非Daemon线程，否则Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。
在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。

线程同步
-------------

Java 提供了一种通过使用同步块来创建线程和同步它们的任务的方法。Java 中的同步块用 synchronized 关键字标记。Java 中的同步块在某个对象上同步。在同一对象上同步的所有同步块一次只能有一个线程在其中执行。所有其他试图进入同步块的线程都被阻塞，直到同步块内的线程退出该块。

以下是同步块的一般形式： 

要使方法同步，只需在synchronized其声明中添加关键字：

.. code-block:: java

    public class SynchronizedCounter {

        private int c = 0;

        public synchronized void increment() {

            c++;

        }

        public synchronized void decrement() {

            c--;

        }

        public synchronized int value() {

            return c;

        }

    }

如果count是 的实例SynchronizedCounter，那么使这些方法同步有两个效果：

* 首先，对同一对象的同步方法的两次调用不可能交错。当一个线程正在为一个对象执行同步方法时，所有其他为同一对象调用同步方法的线程都会阻塞（挂起执行），直到第一个线程完成对对象的处理。
* 其次，当一个同步方法退出时，它会自动建立一个发生在同一个对象的同步方法的任何后续调用之前的关系。这保证了对象状态的更改对所有线程都是可见的。

.. warning::
    请注意，构造函数不能同步——在synchronized构造函数中使用关键字是一个语法错误。同步构造函数没有意义，因为只有创建对象的线程才能在构造对象时访问它。

同步方法启用了一种防止线程干扰和内存一致性错误的简单策略：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都通过synchronized方法完成。

等待/通知机制
---------------------------------

等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类java.lang.Object上

=============== ================================================================================
方法名称         描述
=============== ================================================================================
notify()        通知一个在对象上等待的线程,使其从 wait)方法返回,而返回的前提是该线程获取到了对象的锁
notifyAll()     通知所有等待在该对象上的线程调用该方法的线程进人 WAITING状态,只有等待另外线程的通知或被中断才会返回,需要注意,调用 wait()方法后,会释放对象的锁
wait( long)     超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返
wait(long, int) 对于超时时间更细粒度的控制,可以达到纳秒
=============== ================================================================================

等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。
两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样。

具体执行过程

#. 使用wait()、notify()和notifyAll()时需要先对调用对象加锁。
#. 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。
#. notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。
#. notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。
#. 从wait()方法返回的前提是获得了调用对象的锁。


.. rubric:: 参考与引用
.. [#f1] 维基百科-线程 https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B
.. [#f2] Lifecycle and States of a Thread in Java https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/?ref=lbp 
.. [#f3] Java 并发编程艺术(方腾飞 著).第四章.Java 并发编程基础